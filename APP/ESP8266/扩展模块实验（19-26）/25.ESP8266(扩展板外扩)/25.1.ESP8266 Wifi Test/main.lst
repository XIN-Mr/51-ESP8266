C51 COMPILER V9.01   MAIN                                                                  10/31/2018 18:58:47 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\main.lst)
                    - TABS(2) OBJECT(main.obj)

line level    source

   1          /*********************************************************************
   2                      巫妖王V3.0开发板例程
   3                   朱有鹏物联网大讲堂出品(www.zhulaoshi.org)      
   4                技术支持和学习讨论请加朱有鹏单片机学习1群 214959925获取
   5          **********************************************************************
   6          实验序列：25.1
   7          实验任务：使用APP结合ESP8266控制巫妖王上的小灯，马达，点阵，蜂鸣器，并在APP显示温度传感器上的温度                 
             -      *
   8          实现现象：已亲自实验为准
   9          硬件接线：将套餐配套的WIFI模块插入巫妖王扩展板，注意模块天线端朝外方向
  10                插入，不要反了。
  11          注意事项：(1) 一定要用配套的WIFI模块，否则可能因为引脚定义不同烧坏板子和模块
  12                    (2) 配套模块发货前已经设置为：
  13                   * 串口波特率设置为： 2400
  14                 * WIFI名称(SSID)为： 朱老师_巫妖王_wifi
  15                 * WIFI密码设置为：   wuyaowang
  16                (3) 单片机下载程序时一定要先拔出WIFI模块，如果插入WIFI模块会
  17                    导致程序下载失败（因为串口复用的缘故）
  18                (4) 正确的实验步骤如下：
  19                   * 第1步：不插入WIFI模块下先将程序hex文件烧录入单片机
  20                 * 第2步：关电源，插入WIFI模块，再重新上电。注意不要在开发板上电
  21                          情况下插拔模块，容易损坏板子和模块。
  22                 * 第3步：待开发板上LED亮起4颗（隔1个亮1个），表示WIFI已经准备好，
  23                          拿出android手机，打开WIFI功能，搜索可用WIFI，选中“朱老师_巫妖王_wifi”
  24                      输入密码“wuyaowang”，连接。若手机提示当前网络不可用是否
  25                      切换时选择否。带手机端显示已连接时表示手机已成功接入开发板
  26                      WIFI模块，WIFI标志会有一个感叹号（表示当前网络不能连接外网）
  27                      这个是正常的，不必理会。
  28                 * 第4步：打开配套提供的android app（如果未安装要先安装），点击
  29                          最上方的开始按钮即可让手机成功连接开发板。
  30                 * 第5步：点击app中各个测试按钮，观察开发板上相应实验现象。
  31          版    本：V1.00
  32          作    者：朱有鹏（AstonZhu）
  33          时    间：2018.10.30                                          
  34          *********************************************************************/
  35          
  36          /*
  37          **********************************************************************
  38          *                         头文件包含
  39          **********************************************************************
  40          */
  41          #include "ds18b20.h"
  42          
  43          /*
  44          **********************************************************************
  45          *                         本地宏定义
  46          **********************************************************************
  47          */ 
  48          
  49          #define MATRIX_PORT   P0    // 点阵LED负极端口
  50          
  51          
  52          /*
  53          **********************************************************************
C51 COMPILER V9.01   MAIN                                                                  10/31/2018 18:58:47 PAGE 2   

  54          *                         本地全局变量
  55          **********************************************************************
  56          */
  57          sbit M1 = P1^0;  // M1接在P1.0
  58           
  59          sbit gBuz = P1^5;     // P1.5通过ULN2003放大功率后驱动BUZZER
  60          sbit SCK = P3^6;      // SCK上升沿移位
  61          sbit RCK = P3^5;      // RCK上升沿串行输出寄存器锁存
  62          sbit SER = P3^4;      // SER引脚送字节数据进去
  63          
  64          code u8 init_1_8266[] ="AT+CIPMUX=1\r\n";//设置8266为多连接模式(建立TCP server的前提)
  65          code u8 init_2_8266[] ="AT+CIPSERVER=1\r\n";//建立 TCP server 
  66          code u8 init_3_8266[] ="AT+CIPSEND=0,5\r\n";//8266朝手机发送多少字节 
  67          
  68          u8 flag = 0;//串口接收数据标志位，当8266初始化完后被改写
  69          u8 Buffer[40] = {0};      //从串口接收的数据
  70          u8 i = 0;//Buffer的index
  71          
  72          // 点阵列选值，数组每个元素的值选中其中一列
  73          code u8 gLineCode[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};
  74          code u8 gZhu[] = {0x73,0xD6,0x58,0xFF,0x58,0x54,0x52,0x12};   // 汉字 朱
  75             
  76          /*
  77          **********************************************************************
  78          *                         函数原型声明
  79          **********************************************************************
  80          */
  81          void delay1ms(u16 i);
  82          void Hc595SendByte(u8 dat);
  83          void MatrixDisplay(u8 *zimo);
  84          void UartInit(void);
  85          void BuzzerOnOff(void);
  86          void UartSendBytes(u8 *c);
  87          u16 TempDisplayTest(void);
  88          
  89          
  90          void main() 
  91          {
  92   1        u16 temp = 0;
  93   1        u8 temps[6] = {0};
  94   1      
  95   1        temps[2] = '.';
  96   1          M1 = 0;
  97   1        UartInit();//串口初始化
  98   1        delay1ms(1000);
  99   1        
 100   1        UartSendBytes(init_1_8266);//设置8266为多连接模式(建立TCP server的前提)
 101   1        delay1ms(1000);
 102   1        UartSendBytes(init_2_8266);//建立 TCP server
 103   1        delay1ms(1000);
 104   1        P2 = 0x55;//表示可以wifi连接8266了
 105   1        flag = 1;//开启串口接收数据
 106   1        while (1)
 107   1        {   
 108   2          switch (Buffer[9])      //根据手机输入的键值不同，执行不同的内容
 109   2          {
 110   3            case '1':
 111   3              P2 = 0x0;//点亮所有灯
 112   3              break;
 113   3            case '2':
 114   3              P2 = 0xff;//熄灭所有灯
 115   3              break;
C51 COMPILER V9.01   MAIN                                                                  10/31/2018 18:58:47 PAGE 3   

 116   3            case '3':
 117   3              M1 = 1;//马达转
 118   3              break;
 119   3            case '4':
 120   3              M1 = 0;//马达停
 121   3              break;
 122   3            case '5':
 123   3              BuzzerOnOff();//蜂鸣器叫
 124   3            break;
 125   3            case '6':
 126   3              //蜂鸣器静
 127   3              break;
 128   3            case '7':
 129   3              MatrixDisplay(gZhu);//点阵亮
 130   3              break;
 131   3            case '8':
 132   3              //点阵灭
 133   3              break;
 134   3            case '9'://发送18b20温度
 135   3              temp = TempDisplayTest();
 136   3              temps[0] = temp /1000 + '0';
 137   3              temp %= 1000;
 138   3              temps[1] = temp/100 + '0';
 139   3              temp %= 100;
 140   3              temps[3] = temp/10 + '0';
 141   3              temp %= 10;
 142   3              temps[4] = temp + '0';
 143   3              UartSendBytes(init_3_8266);//确定发送数据长度(5个字节)
 144   3              delay1ms(10);
 145   3              UartSendBytes(temps);//发送温度数据
 146   3              Buffer[9] = 'x';
 147   3              P2 = 0x55;
 148   3              break;
 149   3            default:
 150   3              break;
 151   3          }
 152   2        }
 153   1      }
 154          
 155          
 156          /********************************************************************
 157          * 名称 : Delay_1ms()
 158          * 功能 : 延时子程序，延时时间为 1ms * x
 159          * 输入 : x (延时一毫秒的个数)
 160          * 输出 : 无
 161          ***********************************************************************/
 162          void delay1ms(u16 i)   //误差 0us
 163          {
 164   1          u8 a,b,c;
 165   1      
 166   1        for(;i>0;i--)
 167   1            for(c=1;c>0;c--)
 168   1                for(b=142;b>0;b--)
 169   1                    for(a=2;a>0;a--);
 170   1      }
 171          
 172          /*********************************************************************
 173          * 函 数 名       : Hc595SendByte
 174          * 函数功能     : 通过74HC595串行移位发送一个字节出去
 175          * 参数列表       : dat - 待发送的字节数据
 176          * 函数输出       : 无
 177          *********************************************************************/
C51 COMPILER V9.01   MAIN                                                                  10/31/2018 18:58:47 PAGE 4   

 178          void Hc595SendByte(u8 dat)
 179          {
 180   1        u8 i = 0, j = 0;
 181   1      
 182   1        SCK = 0;        // 将SCK置为初始状态
 183   1        RCK = 0;        // 将RCK置为初始状态
 184   1      
 185   1        for (i=0; i<8; i++)
 186   1        {
 187   2          SER = dat & (0x01);
 188   2          dat >>= 1;
 189   2      
 190   2          SCK = 1;
 191   2          j++;          // 延时代码，等同于nop指令
 192   2          j++;        // 延时代码，等同于nop指令
 193   2          SCK = 0;  
 194   2        }
 195   1      
 196   1        RCK = 1;
 197   1        j++;          // 延时代码，等同于nop指令
 198   1        j++;          // 延时代码，等同于nop指令
 199   1      }
 200          
 201          /*********************************************************************
 202          * 函 数 名       : MatrixDisplay
 203          * 函数功能     : 循环刷新显示字模到点阵上
 204          * 参数列表       : zimo - 待显示的字模数组
 205          * 函数输出       : 无
 206          *********************************************************************/
 207          void MatrixDisplay(u8 *zimo)
 208          {
 209   1        u8 i = 0;
 210   1        u8 j = 0;//gai
 211   1        while(1)
 212   1        {
 213   2          for(i=0;i<8;i++)
 214   2          {
 215   3            MATRIX_PORT = gLineCode[i];         // 位选
 216   3            Hc595SendByte(zimo[i]);   // 发送段选数据
 217   3            Hc595SendByte(0x00);      // 消隐
 218   3          }
 219   2          j++;//gai
 220   2          if(j==200)//gai
 221   2          {
 222   3            break;
 223   3          } 
 224   2        }
 225   1      }
 226          
 227          
 228          
 229          /********************************************************************
 230          * 名称 : UartIsr()
 231          * 功能 : 串口中断处理程序
 232          * 输入 : 无
 233          * 输出 : 无
 234          ***********************************************************************/
 235          void UartIsr(void) interrupt 4
 236          {
 237   1        EA = 0;
 238   1        if (RI == 1)        //当硬件接收到一个数据时，RI会置位
 239   1        {
C51 COMPILER V9.01   MAIN                                                                  10/31/2018 18:58:47 PAGE 5   

 240   2          RI = 0;
 241   2          if(flag == 1)   //初始化完8266后，此处才为真
 242   2          {
 243   3            Buffer[i] = SBUF;//将接收到的字符放入Buffer
 244   3            i++;
 245   3            if(SBUF == 0x0a)//遇到换行就回到Buffer的头部开始存
 246   3            {
 247   4              i = 0;
 248   4            }
 249   3          }   
 250   2        }
 251   1        EA = 1;
 252   1      }
 253          
 254          
 255          /********************************************************************
 256          * 名称 : UartInit()
 257          * 功能 : 串口初始化，注意波特率是2400
 258          * 输入 : 无
 259          * 输出 : 无
 260          ***********************************************************************/
 261          void UartInit(void)
 262          {
 263   1          TMOD = 0x20;
 264   1          SCON = 0x50;
 265   1          TH1 = 0xF3;
 266   1          TL1 = TH1;
 267   1          PCON = 0x00;
 268   1          EA = 1;
 269   1          ES = 1;
 270   1          TR1 = 1;    
 271   1      }
 272          
 273          /*********************************************************************
 274          * 函 数 名       : BuzzerOnOff
 275          * 函数功能     : 给蜂鸣器开关各一段时间
 276          * 参数列表       : 无
 277          * 函数输出       : 无
 278          *********************************************************************/
 279          void BuzzerOnOff(void)
 280          {
 281   1        gBuz = 1;
 282   1        delay1ms(1);
 283   1        gBuz = 0;
 284   1        delay1ms(1);
 285   1      }
 286          
 287          
 288          /*********************************************************************
 289          * 函 数 名       : UartSendBytes
 290          * 函数功能     : 通过串口往外发送数据
 291          * 参数列表       : uchar *c,要发的数据
 292          * 函数输出       : 无
 293          *********************************************************************/
 294          void UartSendBytes(u8 *c)//串口发送数据
 295          {
 296   1        EA = 0;
 297   1        while(*c != '\0')
 298   1        {
 299   2          SBUF = *c;
 300   2          while(!TI);
 301   2          TI = 0;
C51 COMPILER V9.01   MAIN                                                                  10/31/2018 18:58:47 PAGE 6   

 302   2            c++;
 303   2        
 304   2        }
 305   1        EA = 1;
 306   1      }
 307          
 308          /*********************************************************************
 309          * 函 数 名       : TempDisplayTest
 310          * 函数功能     : 通过串口往外发送数据
 311          * 参数列表       : 无
 312          * 函数输出       : u16 tDisp,最终的温度值
 313          *********************************************************************/
 314          u16 TempDisplayTest(void)
 315          {
 316   1        u16 temp = 0;         // 用来暂存12位的AD值
 317   1        u8 tmh = 0, tml = 0;      // 用来暂存2个8位的AD值
 318   1        u16 tDisp = 0;          // 用来存储乘以100倍后的温度值
 319   1        double t = 0;         // 用来存储转换后以摄氏度为单位的温度值
 320   1      
 321   1        Ds18b20TempConvertCmd();    // 先写入转换命令
 322   1        Ds18b20TempReadCmd();     // 然后等待转换完后发送读取温度命令
 323   1        tml = Ds18b20ReadByte();    // 读取温度值共16位，先读低字节
 324   1        tmh = Ds18b20ReadByte();    // 再读高字节
 325   1      
 326   1        temp = tml | (tmh << 8);    // 默认是12位分辨率，前面4个S位是符号位
 327   1        
 328   1        // 正温度时符号位为0，下面代码计算没有考虑负温度情况，因为我们实验是在
 329   1        // 室温下做的，如果要考虑到负温度的情况，代码中要先判断S位，若S位为1则
 330   1        // 必须点去掉S的1再计算，计算后的值加负号即可。
 331   1        t = temp * 0.0625;
 332   1        tDisp = (u16)(t * 100);     // 为方便显示将温度值乘以100后强转为u16
 333   1        return tDisp;
 334   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    591    ----
   CONSTANT SIZE    =     70    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     42      17
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
