/*********************************************************************
						巫妖王V3.0开发板例程
			   朱有鹏物联网大讲堂出品(www.zhulaoshi.org)      
		  技术支持和学习讨论请加朱有鹏单片机学习1群 214959925获取
**********************************************************************
实验序列：25.1
实验任务：使用APP结合ESP8266控制巫妖王上的小灯，马达，点阵，蜂鸣器，并在APP显示温度传感器上的温度											  *
实现现象：已亲自实验为准
硬件接线：将套餐配套的WIFI模块插入巫妖王扩展板，注意模块天线端朝外方向
		  插入，不要反了。
注意事项：(1) 一定要用配套的WIFI模块，否则可能因为引脚定义不同烧坏板子和模块
          (2) 配套模块发货前已经设置为：
		  	 * 串口波特率设置为：	2400
			 * WIFI名称(SSID)为：	朱老师_巫妖王_wifi
			 * WIFI密码设置为：  	wuyaowang
		  (3) 单片机下载程序时一定要先拔出WIFI模块，如果插入WIFI模块会
		      导致程序下载失败（因为串口复用的缘故）
		  (4) 正确的实验步骤如下：
		  	 * 第1步：不插入WIFI模块下先将程序hex文件烧录入单片机
			 * 第2步：关电源，插入WIFI模块，再重新上电。注意不要在开发板上电
			          情况下插拔模块，容易损坏板子和模块。
			 * 第3步：待开发板上LED亮起4颗（隔1个亮1个），表示WIFI已经准备好，
			          拿出android手机，打开WIFI功能，搜索可用WIFI，选中“朱老师_巫妖王_wifi”
					  输入密码“wuyaowang”，连接。若手机提示当前网络不可用是否
					  切换时选择否。带手机端显示已连接时表示手机已成功接入开发板
					  WIFI模块，WIFI标志会有一个感叹号（表示当前网络不能连接外网）
					  这个是正常的，不必理会。
			 * 第4步：打开配套提供的android app（如果未安装要先安装），点击
			          最上方的开始按钮即可让手机成功连接开发板。
			 * 第5步：点击app中各个测试按钮，观察开发板上相应实验现象。
版    本：V1.00
作    者：朱有鹏（AstonZhu）
时	  间：2018.10.30																				  
*********************************************************************/

/*
**********************************************************************
*                         头文件包含
**********************************************************************
*/
#include "ds18b20.h"

/*
**********************************************************************
*                         本地宏定义
**********************************************************************
*/ 

#define MATRIX_PORT		P0		// 点阵LED负极端口


/*
**********************************************************************
*                         本地全局变量
**********************************************************************
*/
sbit M1 = P1^0;	 // M1接在P1.0
 
sbit gBuz = P1^5;			// P1.5通过ULN2003放大功率后驱动BUZZER
sbit SCK = P3^6; 			// SCK上升沿移位
sbit RCK = P3^5;			// RCK上升沿串行输出寄存器锁存
sbit SER = P3^4; 			// SER引脚送字节数据进去

code u8 init_1_8266[] ="AT+CIPMUX=1\r\n";//设置8266为多连接模式(建立TCP server的前提)
code u8 init_2_8266[] ="AT+CIPSERVER=1\r\n";//建立 TCP server 
code u8 init_3_8266[] ="AT+CIPSEND=0,5\r\n";//8266朝手机发送多少字节 

u8 flag = 0;//串口接收数据标志位，当8266初始化完后被改写
u8 Buffer[40] = {0};      //从串口接收的数据
u8 i = 0;//Buffer的index

// 点阵列选值，数组每个元素的值选中其中一列
code u8 gLineCode[]={0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f};
code u8 gZhu[] = {0x73,0xD6,0x58,0xFF,0x58,0x54,0x52,0x12};		// 汉字 朱
   
/*
**********************************************************************
*                         函数原型声明
**********************************************************************
*/
void delay1ms(u16 i);
void Hc595SendByte(u8 dat);
void MatrixDisplay(u8 *zimo);
void UartInit(void);
void BuzzerOnOff(void);
void UartSendBytes(u8 *c);
u16 TempDisplayTest(void);


void main() 
{
	u16 temp = 0;
	u8 temps[6] = {0};

	temps[2] = '.';
   	M1 = 0;
	UartInit();//串口初始化
	delay1ms(1000);
	
	UartSendBytes(init_1_8266);//设置8266为多连接模式(建立TCP server的前提)
	delay1ms(1000);
	UartSendBytes(init_2_8266);//建立 TCP server
	delay1ms(1000);
	P2 = 0x55;//表示可以wifi连接8266了
	flag = 1;//开启串口接收数据
	while (1)
	{ 	
		switch (Buffer[9])      //根据手机输入的键值不同，执行不同的内容
		{
			case '1':
				P2 = 0x0;//点亮所有灯
				break;
			case '2':
				P2 = 0xff;//熄灭所有灯
				break;
			case '3':
				M1 = 1;//马达转
				break;
			case '4':
				M1 = 0;//马达停
				break;
			case '5':
				BuzzerOnOff();//蜂鸣器叫
			break;
			case '6':
				//蜂鸣器静
				break;
			case '7':
				MatrixDisplay(gZhu);//点阵亮
				break;
			case '8':
				//点阵灭
				break;
			case '9'://发送18b20温度
				temp = TempDisplayTest();
				temps[0] = temp /1000 + '0';
				temp %= 1000;
				temps[1] = temp/100 + '0';
				temp %= 100;
				temps[3] = temp/10 + '0';
				temp %= 10;
				temps[4] = temp + '0';
				UartSendBytes(init_3_8266);//确定发送数据长度(5个字节)
				delay1ms(10);
				UartSendBytes(temps);//发送温度数据
				Buffer[9] = 'x';
				P2 = 0x55;
				break;
			default:
				break;
		}
	}
}


/********************************************************************
* 名称 : Delay_1ms()
* 功能 : 延时子程序，延时时间为 1ms * x
* 输入 : x (延时一毫秒的个数)
* 输出 : 无
***********************************************************************/
void delay1ms(u16 i)   //误差 0us
{
    u8 a,b,c;

	for(;i>0;i--)
    	for(c=1;c>0;c--)
        	for(b=142;b>0;b--)
            	for(a=2;a>0;a--);
}

/*********************************************************************
* 函 数 名       : Hc595SendByte
* 函数功能		 : 通过74HC595串行移位发送一个字节出去
* 参数列表       : dat - 待发送的字节数据
* 函数输出    	 : 无
*********************************************************************/
void Hc595SendByte(u8 dat)
{
	u8 i = 0, j = 0;

	SCK = 0;				// 将SCK置为初始状态
	RCK = 0;				// 将RCK置为初始状态

	for (i=0; i<8; i++)
	{
		SER = dat & (0x01);
		dat >>= 1;

		SCK = 1;
		j++;			  	// 延时代码，等同于nop指令
		j++;				// 延时代码，等同于nop指令
		SCK = 0;	
	}

	RCK = 1;
	j++;					// 延时代码，等同于nop指令
	j++;					// 延时代码，等同于nop指令
}

/*********************************************************************
* 函 数 名       : MatrixDisplay
* 函数功能		 : 循环刷新显示字模到点阵上
* 参数列表       : zimo - 待显示的字模数组
* 函数输出    	 : 无
*********************************************************************/
void MatrixDisplay(u8 *zimo)
{
	u8 i = 0;
	u8 j = 0;//gai
	while(1)
	{
		for(i=0;i<8;i++)
		{
			MATRIX_PORT = gLineCode[i];		  		// 位选
			Hc595SendByte(zimo[i]);		// 发送段选数据
			Hc595SendByte(0x00);  		// 消隐
		}
		j++;//gai
		if(j==200)//gai
		{
			break;
		}	
	}
}



/********************************************************************
* 名称 : UartIsr()
* 功能 : 串口中断处理程序
* 输入 : 无
* 输出 : 无
***********************************************************************/
void UartIsr(void) interrupt 4
{
	EA = 0;
	if (RI == 1)   			//当硬件接收到一个数据时，RI会置位
	{
		RI = 0;
		if(flag == 1)		//初始化完8266后，此处才为真
		{
			Buffer[i] = SBUF;//将接收到的字符放入Buffer
			i++;
			if(SBUF == 0x0a)//遇到换行就回到Buffer的头部开始存
			{
				i = 0;
			}
		}	  
	}
	EA = 1;
}


/********************************************************************
* 名称 : UartInit()
* 功能 : 串口初始化，注意波特率是2400
* 输入 : 无
* 输出 : 无
***********************************************************************/
void UartInit(void)
{
    TMOD = 0x20;
    SCON = 0x50;
    TH1 = 0xF3;
    TL1 = TH1;
    PCON = 0x00;
    EA = 1;
    ES = 1;
    TR1 = 1;		
}

/*********************************************************************
* 函 数 名       : BuzzerOnOff
* 函数功能		 : 给蜂鸣器开关各一段时间
* 参数列表       : 无
* 函数输出    	 : 无
*********************************************************************/
void BuzzerOnOff(void)
{
	gBuz = 1;
	delay1ms(1);
	gBuz = 0;
	delay1ms(1);
}


/*********************************************************************
* 函 数 名       : UartSendBytes
* 函数功能		 : 通过串口往外发送数据
* 参数列表       : uchar *c,要发的数据
* 函数输出    	 : 无
*********************************************************************/
void UartSendBytes(u8 *c)//串口发送数据
{
	EA = 0;
	while(*c != '\0')
	{
		SBUF = *c;
		while(!TI);
		TI = 0;
	   	c++;
	
	}
	EA = 1;
}

/*********************************************************************
* 函 数 名       : TempDisplayTest
* 函数功能		 : 通过串口往外发送数据
* 参数列表       : 无
* 函数输出    	 : u16 tDisp,最终的温度值
*********************************************************************/
u16 TempDisplayTest(void)
{
	u16 temp = 0;	 				// 用来暂存12位的AD值
	u8 tmh = 0, tml = 0;			// 用来暂存2个8位的AD值
	u16 tDisp = 0;					// 用来存储乘以100倍后的温度值
	double t = 0;					// 用来存储转换后以摄氏度为单位的温度值

	Ds18b20TempConvertCmd();		// 先写入转换命令
	Ds18b20TempReadCmd();			// 然后等待转换完后发送读取温度命令
	tml = Ds18b20ReadByte();		// 读取温度值共16位，先读低字节
	tmh = Ds18b20ReadByte();		// 再读高字节

	temp = tml | (tmh << 8);		// 默认是12位分辨率，前面4个S位是符号位
	
	// 正温度时符号位为0，下面代码计算没有考虑负温度情况，因为我们实验是在
	// 室温下做的，如果要考虑到负温度的情况，代码中要先判断S位，若S位为1则
	// 必须点去掉S的1再计算，计算后的值加负号即可。
	t = temp * 0.0625;
	tDisp = (u16)(t * 100);			// 为方便显示将温度值乘以100后强转为u16
	return tDisp;
}