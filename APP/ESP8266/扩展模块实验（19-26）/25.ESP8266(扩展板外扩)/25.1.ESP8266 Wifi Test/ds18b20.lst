C51 COMPILER V9.01   DS18B20                                                               10/31/2018 18:58:46 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE DS18B20
OBJECT MODULE PLACED IN ds18b20.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\ds18b20.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\ds18b2
                    -0.lst) TABS(2) OBJECT(ds18b20.obj)

line level    source

   1          /*********************************************************************
   2                      巫妖王V3.0开发板例程
   3                   朱有鹏物联网大讲堂出品(www.zhulaoshi.org)      
   4                技术支持和学习讨论请加朱有鹏单片机学习1群 214959925获取
   5          **********************************************************************
   6          模块名称：DS18B20
   7          模块功能: ds18b20单总线温度采集芯片   
   8          硬件接线：参考图16.1.DS18B20加LCD1602.png中方向插入DS18B20，注意插反了
   9                一定会烧掉DS18B20，千万注意不要接反了，板子丝印画了半圆弧线
  10                就是用来引导芯片插入方向的。初学者往往很容易忽视这个细节，结
  11                果很快就损失一颗DS18B20传感器芯片。
  12          注意事项：(1) 不要插反了，会烧坏芯片。
  13                (2) DS18B20编程的关键是时序，时序的关键是延时时间要准确，移植
  14                    别人的程序时要注意他的延时函数是基于多少频率的晶振的，而且
  15                  高性能51单片机还有12T、6T、1T工作模式，都会影响延时函数，
  16                  移植时一定要注意这些细节。
  17                (3) 像DS18B20这类温度传感器很多年了，网上遍地都是写好的代码，
  18                    移植时只要注意延时函数的精准性也不会有问题。所以本模块关键
  19                  是用来学习看时序图，学习如何根据时序图编程写代码。
  20          版    本：V1.00
  21          作    者：朱有鹏（AstonZhu）
  22          时    间：2018.10.30                        
  23          **********************************************************************/
  24          
  25          /*
  26          **********************************************************************
  27          *                         头文件包含
  28          **********************************************************************
  29          */
  30          #include "ds18b20.h"
  31          
  32          
  33          /*
  34          **********************************************************************
  35          *                         本地全局变量
  36          **********************************************************************
  37          */
  38          sbit gIO = P3^7;            // DS18B20的单总线IO接在P3.7上
  39          
  40          /*
  41          **********************************************************************
  42          *                         内部函数原型声明
  43          **********************************************************************
  44          */
  45          static void delay5ms(void);
  46          static void delay15us(void);
  47          static void delay45us(void);
  48          static void delay70us(void);
  49          static void delay750us(void);
  50          static void delay1ms(void);
  51          static void delay750ms(void);
  52          static u8 Ds18b20Init(void);
  53          static void Ds18b20WriteByte(u8 dat);
  54          
C51 COMPILER V9.01   DS18B20                                                               10/31/2018 18:58:46 PAGE 2   

  55          
  56          
  57          
  58          /************ 以下为低层时序函数 ************************************/ 
  59          
  60          /*********************************************************************
  61          * 函 数 名       : Ds18b20Init
  62          * 函数功能     : 按照DS18B20底层时序要求进行传感器初始化
  63          * 参数列表       : 无
  64          * 函数输出       : 若初始化成功则返回0，否则返回1
  65          *********************************************************************/
  66          static u8 Ds18b20Init(void)
  67          {
  68   1        u8 i = 0;
  69   1      
  70   1        gIO = 0;      // 时序要求将总线拉低480us~960us
  71   1        delay750us();   // 实际延时750us，符合480-960之间的条件
  72   1        gIO = 1;      // 然后拉高总线，如果DS18B20做出反应会将在15us~60us后总线被拉低
  73   1      
  74   1        i = 0;
  75   1        while (gIO)     // 等待DS18B20拉低总线
  76   1        {
  77   2          i++;
  78   2          if(i>5)     // 等待 15*5=75us，如果还没拉低则可以认为初始化失败了
  79   2          {
  80   3            return 1; // 初始化失败
  81   3          }
  82   2          delay15us();  // 隔15us查看一下是否收到DS18B20的回应
  83   2        }
  84   1        return 0;     //初始化成功
  85   1      }
  86          
  87          
  88          /*********************************************************************
  89          * 函 数 名       : Ds18b20WriteByte
  90          * 函数功能     : 按照DS18B20底层时序要求向DS18B20写入1字节数据
  91          * 参数列表       : dat - 待写入的1字节数据
  92          * 函数输出       : 无
  93          *********************************************************************/
  94          static void Ds18b20WriteByte(u8 dat)
  95          {
  96   1        u16 i = 0, j = 0;
  97   1      
  98   1        for (j=0; j<8; j++)
  99   1        {
 100   2          gIO = 0;            // 每写入一位数据之前先把总线拉低1us
 101   2          i++;
 102   2          gIO = dat & 0x01;     // 然后写入一个数据，从最低位开始
 103   2          delay70us();      // 时序要求最少60us
 104   2          gIO = 1;        // 然后释放总线，至少1us给总线恢复时间才能接着写入第二个数值
 105   2          dat >>= 1;
 106   2        }
 107   1      }
 108          
 109          
 110          /*********************************************************************
 111          * 函 数 名       : Ds18b20ReadByte
 112          * 函数功能     : 按照DS18B20底层时序要求从DS18B20中读取1字节数据
 113          * 参数列表       : 无
 114          * 函数输出       : 返回读取到的1字节数据
 115          *********************************************************************/
 116          u8 Ds18b20ReadByte(void)
C51 COMPILER V9.01   DS18B20                                                               10/31/2018 18:58:46 PAGE 3   

 117          {
 118   1        u8 byte = 0, bi = 0;
 119   1        u16 i = 0, j = 0;
 120   1          
 121   1        for (j=8; j>0; j--)
 122   1        {
 123   2          gIO = 0;    // 先将总线拉低1us
 124   2          i++;
 125   2          gIO = 1;    // 然后释放总线
 126   2          i++;
 127   2          i++;      // 延时6us等待数据稳定
 128   2          bi = gIO;   // 读取数据，从最低位开始读取
 129   2          /*将byte左移一位，然后与上右移7位后的bi，注意移动之后移掉那位补0。*/
 130   2          byte = (byte >> 1) | (bi << 7); 
 131   2          //byte |= (bi << (8-j));
 132   2          delay45us();
 133   2        }       
 134   1        return byte;
 135   1      }
 136          
 137          
 138          /*************** 高层时序 *************************************/
 139          
 140          void Ds18b20TempConvertCmd(void)
 141          {
 142   1        Ds18b20Init();
 143   1        delay1ms();
 144   1        Ds18b20WriteByte(0xcc);   // 跳过ROM操作命令     
 145   1        Ds18b20WriteByte(0x44);     // 温度转换命令
 146   1        delay750ms();       // 等待转换成功，750ms肯定够了
 147   1      }
 148          
 149          void Ds18b20TempReadCmd(void)
 150          { 
 151   1        Ds18b20Init();
 152   1        delay1ms();
 153   1        Ds18b20WriteByte(0xcc);   // 跳过ROM操作命令
 154   1        Ds18b20WriteByte(0xbe);   // 发送读取温度命令
 155   1      }
 156          
 157          
 158          
 159          /*************** 注意下面的延时函数都是12M晶振模式下的 ******************/
 160          static void delay15us(void)   //误差 0us
 161          {
 162   1          unsigned char a;
 163   1          for(a=6;a>0;a--);
 164   1      }
 165          
 166          static void delay45us(void)   //误差 0us
 167          {
 168   1          unsigned char a;
 169   1          for(a=21;a>0;a--);
 170   1      }
 171          
 172          static void delay70us(void)   //误差 0us
 173          {
 174   1          unsigned char a,b;
 175   1          for(b=1;b>0;b--)
 176   1              for(a=32;a>0;a--);
 177   1      }
 178          
C51 COMPILER V9.01   DS18B20                                                               10/31/2018 18:58:46 PAGE 4   

 179          
 180          static void delay750us(void)   //误差 0us
 181          {
 182   1          unsigned char a,b;
 183   1          for(b=83;b>0;b--)
 184   1              for(a=3;a>0;a--);
 185   1      }
 186          
 187          static void delay1ms(void)   //误差 0us
 188          {
 189   1          unsigned char a,b,c;
 190   1          for(c=1;c>0;c--)
 191   1              for(b=142;b>0;b--)
 192   1                  for(a=2;a>0;a--);
 193   1      }
 194          
 195          static void delay750ms(void)   //误差 0us
 196          {
 197   1          unsigned char a,b,c;
 198   1          for(c=167;c>0;c--)
 199   1              for(b=136;b>0;b--)
 200   1                  for(a=15;a>0;a--);
 201   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    275    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      12
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
